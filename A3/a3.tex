\documentclass[10pt]{article}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{fancybox}
\usepackage{tikz}
\usepackage{listings}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=10mm,
 bottom=15mm
 }
 
\usepackage{color}
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\linespread{1.3}

\title{CSC263H1 Assignment 3}
\author{Jiatao Xiang, Xu Wang, Huakun Shen}
\date{February 14th, 2019}

\begin{document}
\maketitle

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

\section*{Question 1}
\textbf{Insert:}\\
\ovalbox{
\begin{tikzpicture}[level/.style={sibling distance=60mm/#1}]
\node [circle,draw, label=right:$BF: +1$] (z){$5$}
  child {node [circle,draw, label=right:$BF: -1$] (lz) {$0$}
    child {node [circle,draw, label=right:$BF: -1$] (llz) {$-2$}
      child {node [circle, draw, label=right:$BF: 0$] (lllz) {$-5$}}
      child[fill=none]{edge from parent[draw=none]} 
    }
    child {node [circle,draw, label=right:$BF: 0$] (lrz) {$2$}
    }
  }
  child {node [circle,draw, label=right:$BF: -1$] (rz) {$19$}
    child {node [circle,draw, label=right:$BF: -1$] (rlz) {$13$}
    	child {node [circle, draw, label=right:BF: +1] (rllz) {$6$}
    		child[fill=none]{edge from parent[draw=none]}
    		child {node [circle, draw, label=right:$BF: 0$] (rllrz) {$7$}}
    	}
    	child {node [circle, draw, label=right:$BF: 0$] (rlrz) {$14$}}
    }
  child {node [circle,draw, label=right:$BF: +1$] (rrz) {$25$}
    child[fill=none]{edge from parent[draw=none]}
    child {node [circle, draw, label=right:$BF: 0$] (rrrz) {$28$}}		
	}
};
\end{tikzpicture}
}

\textbf{delete:}\\
\ovalbox{
\begin{tikzpicture}[level/.style={sibling distance=60mm/#1}]
\node [circle,draw, label=right:$BF: 0$] (z){$13$}
  child {node [circle,draw, label=right:$BF: 0$] (lz) {$5$}
    child {node [circle,draw, label=right:$BF: 0$] (llz) {$-2$}
      child {node [circle, draw, label=right:$BF: 0$] (lllz) {$-5$}}
      child {node [circle, draw, label=right:$BF: 0$] (lllz) {$0$}}
    }
    child {node [circle,draw, label=right:$BF: +1$] (lrz) {$6$}
    	child[fill=none]{edge from parent[draw=none]}
    	child {node [circle, draw, label=right:$BF: 0$] (b) {$7$}}
    }
  }
  child {node [circle,draw, label=right:$BF: +1$] (rz) {$19$}
    child {node [circle,draw, label=right:$BF: 0$] (rlz) {$14$}
    }
  child {node [circle,draw, label=right:$BF: +1$] (rrz) {$25$}
    child[fill=none]{edge from parent[draw=none]}
    child {node [circle, draw, label=right:$BF: 0$] (rrrz) {$28$}}		
	}
};
\end{tikzpicture}
}
\section*{Question 2}
\begin{enumerate}
\item[a.]
Define a new data structure, D, which is a AVL tree. Let's call this \textbf{id\_tree}. Each of its node contains parent, left child, right child, balance factor, identifier, price and rating, and we set its identifier as key.\\
\textbf{Description of the Algorithm}\\
Notice that: D is the root node of the AVL tree.\\
\textbf{AddBook(D, x):} we perform the insert operation(which also includes rebalancing) of an AVL tree that we discussed in lecture. This takes $\mathcal{O}(\log{}n)$.\\
\textbf{SearchBook(D, id):} we perform the search operation of an AVL tree that we discussed in lecture. This takes $\mathcal{O}(\log{}n)$.\\
\item[b.]
We add one more AVL tree to our existed data structure such that each of its node contains price (which is also the \textbf{key}), rating, the pointers to its left and right child, the max\_right\_rating (this stores the maximum rating among all nodes in the subtree rooted at a node's right child), and the max\_left\_rating (this stores the maximum rating among all nodes in the subtree rooted at a node's left child). Let's call it \textbf{rating\_tree}.\\
\textbf{Modification to existed data structure:}\\
\textbf{AddBook}(D, x):\\
We now need to add one more attribute, \textbf{rating\_alias}, to nodes in id\_tree. This is the pointer that points to the node in rating\_tree which has the same identifier.\\
In this case, AddBook(D, x) defined previously also needs to add $x$ to the rating\_tree, and a pointer to the $x$ in rating\_tree is returned and stored in the corresponding node in id\_tree ($\mathcal{O}(\log{}n)$). Then, rebalancing both trees ($\mathcal{O}(1)$), and update the max\_left\_rating and max\_right\_rating of each node in rating\_tree ($\mathcal{O}(\log{}n)$). Thus, the total time taken is still $\mathcal{O}(\log{}n)$.\\
\textbf{SearchBook}(D, id):\\
The operation SearchBook(D, id) remains same.\\
\textbf{Description of the Algorithm:}\\
We start with the root of D, there exists three conditions:\\
First, when D has only right children: if $D.price \leq p$, we need to check  D's rating and its max\_right\_rating, and return the greater one. If $D.price > p$, -1 is returned, since there is no node satisfying the requirement.\\
Second, when D has only left children: if $D.price \leq p$, we need to check  D's rating and its max\_left\_rating, and return the greater one. If $D.price > p$, call BestBookRating recursively to the maximum rating of D's left subtree.\\
Third, when D has both left and right child, if $D.price > p$, call BestBookRating recursively to find the maximum rating of the left subtree. Otherwise, we return the max\{D.max\_left\_rating, D.rating, BestBookRating(D.right, p)\}.\\
Simply speaking, the algorithm will traverse downwards from the root of the tree and it will go in exactly one direction (either to the left side or the right side) or return value directly for each call, so the max path it will go through is less than or equal to the height of the tree. Thus, run time is $\mathcal{O}(logn)$.\\
Let $T(n)$ be the run time of the algorithm.
\begin{equation*}
  T(n)=\begin{cases}
    c, &if\ leaf\\
    T( \lfloor\frac{n}{2}\rfloor) + c_1, &if\ left\ is\ NULL\\
    T(\lfloor\frac{n}{2}\rfloor) + c_2, &if\ right\ is\ NULL\\
    T(\lfloor\frac{n}{2}\rfloor) + c_3, &if\ has\ both\ left\ and\ right
  \end{cases}
\end{equation*}

\begin{lstlisting}[language=Python]
def BestBookRating(D, p):
	if D is leaf:
		if D.price <= p:
			return D.rating
		return -1
	elif D has only right child:
		if D.price <= p:
			return max(BestBookRating(D.right, p), D.rating)
		return -1
	elif D has only left child:
		if D.price <= p:
			return max(D.max_left_rating, D.rating)
		return BestBookRating(D.left, p)
	elif D has both left and right child:
		if D.price > p:
			return BestBookRating(D.left, p)
		return max(D.max_left_rating, BestBookRating(D.right, p), D.rating)
\end{lstlisting}


\item[c.]Description:\\
AllBestBooks(D, p): Based on question a and b, we create another AVL rating tree, where rating is the key of every node and for each node, there is a attribute called RatingFamily which is a AVL Tree that stores node of every book with same rating. every node in the identifier AVL tree has an attribute called rating and that rating is pointing to the node in rating tree whose rating is the same as the rating of that book. In this way whenever we find the rating r from question b, we can search this rating in AVL rating tree and return RatingFamily, that is all node with rating r. The largest depth of AVL rating tree is log(n), thus this will cost at most $\mathcal{O}(logn)$. 

\item[d.] Description:\\
IncreasePrice(D, p)\\
To increment the price of every book in \textbf{D} by $p$ in $\mathcal{O}(1)$, we cannot traverse through \textbf{D} and increment the price of every element by $p$, because that will definitely take at least $\mathcal{O}(n)$ of time.\\
We will define a variable called \textbf{\textit{price\_inflation}} that is initially set to 0.\\
Every time \textit{IncreasePrice(D, p)} is called, \textit{price\_inflation} is incremented by $p$.\\
In addition, we will modify the price attribute of each node to be \textbf{\textit{original price + price\_inflation}},
note that here \textbf{\textit{price\_inflation}} is a pointer, so that every time the variable is modified, we don't have to modify the price of every node.\\
In addition, the \textbf{insert(x)} function needs to be modified a little. When inserting a new book, we modify its original price to be \textit{\textbf{original price - price\_inflation}} (here, \textit{\textbf{price\_inflation}} is not a pointer, but just the value of current \textit{\textbf{price\_inflation}}). Then Also add the \textbf{\textit{price\_inflation}} pointer to the new ``\textbf{original price}''. In brief, when we ask for the price of a book $x$, the returned value is actually: \textbf{$x$'s original price - value of price\_inflation at the time when $x$ is inserted + current price\_inflation.}. In the way, the price of a new book wouldn't be affected by previous \textit{\textbf{price\_inflation}}.

\item[e.]Description:\\
DeleteBook(D, id): we first delete the node with the input id from the AVL tree we defined in Part a, this takes $\mathcal{O}(\log n)$. Since for each node in first AVL tree, it has a pointer points to the corresponding node in second AVL tree defined in Part b, then we delete this node from the second AVL tree and this also takes $\mathcal{O}(\log n)$. Lastly, since each node in first AVL tree also contains the rating, so we search in the third AVL tree by rating which takes $\mathcal{O}(\log n)$, and delete the node that has the same identifier from the inner AVL tree which takes $\mathcal{O}(\log n)$. Thus, the whole process takes $\mathcal{O}(\log n)$.


\end{enumerate}



\section*{Question 3}
\begin{enumerate}
\item[a.] Our data structure is based on \textbf{hash table}.\\
\textbf{Idea:} Put every element of set \textbf{B} into a hash table. Then hash every element of set \textbf{A} to a
slot in the hash table, and check whether the element of \textbf{A} is in this slot. If it is not in the slot, then it means that the element of set \textbf{A} is not in set \textbf{B}.\\
\textbf{Pseudo Code:}\\
Suppose \textbf{$\alpha$ = 10}, that is, each slot contains a linked list with size of at most approximately 10 elements.\\
Suppose we have a hash table \textbf{\textit{T}} with a size of $\frac{n}{\alpha}$.\\
Suppose we have a hashing function \textit{\textbf{h(x)}} that would return the index of one of the slots of \textbf{T} given \textbf{\textit{x}} as a input. Also assume \textbf{SUHA}.
\begin{lstlisting}[language=Python]
def h(x, num_slot):
	return x % num_slot
\end{lstlisting}
\begin{lstlisting}[language=Python]
for element in B:
		linked_list = T[h(element, len(T))]
		linked_list.append(element)
		
result = []
for element in A:
		linked_list = T[h(element, len(T))]
		for item in linked_list:
				if element == item:
						break
		result.append(element)
\end{lstlisting}
\item[b.]
Assumptions:\
\begin{itemize}
\item The linked list in each slot of hash table has approximately a length of $\alpha$ = 10
\item Hash table \textbf{T} has a length of $\frac{len(A)}{\alpha}$
\item SUHA for hash function \textbf{\textit{h(x, num\_slot)}}
\end{itemize}
Explanation:\
Part I: put \textbf{B} into \textbf{T}
\begin{enumerate}
\item[1.] Hashing function costs constant time
\item[2.] There are $n$ elements in \textbf{B}, performing hashing function \textbf{\textit{h}} for each element of \textbf{B} costs $\mathcal{O}(n\times1)$ of time.
\end{enumerate}
Part II: match element of \textbf{A} to \textbf{T}
\begin{enumerate}
\item[1.] Each linked list in each slot of \textbf{T} has a size of at most $\alpha$ (by \textbf{SUHA}), which is constant. In the worst case, we have to traverse through every linked list, which costs $\mathcal{O}(\alpha)=\mathcal{O}(1)$ of time.
\item[2.] There are $n$ elements in \textbf{A}, performing step 1 for each of them costs $\mathcal{O}(\alpha n)=\mathcal{O}(n)$ of time.
\end{enumerate}
Part I and Part II altogether cost $\mathcal{O}(n)$ of time.
\item[c.] In The worst case scenario, \textbf{SUHA} may not hold, and every element of B may be hashed into one single slot of \textbf{T}. Then when element of set \textbf{A} tries to find a matching element in this slot, it needs to traverse through the entire linked list and takes $\mathcal{O}(n)$ of time.\\
While there are $n$ elements in set \textbf{A}. If for each of the element in \textbf{A}, the program traverses through the linked list of size $n$ and do not exit early, it will take $\mathcal{O}(n\times n) = \mathcal{O}(n^2)$ of time.
\end{enumerate}


\end{document}
