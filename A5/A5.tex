\documentclass[10pt]{article}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{fancybox}
\usepackage{amsfonts}
\usepackage{amsbsy}
\usepackage{tikz}
\usepackage{listings}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=10mm,
 bottom=15mm
 }
\usepackage{color}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\linespread{1.3}

\title{CSC263H1 Assignment 5}
\author{Jiatao Xiang, Xu Wang, Huakun Shen}
\date{March 14th, 2019}

\begin{document}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4
}
\lstset{style=mystyle}
\maketitle
\section*{Question 1}
\begin{itemize}
\item[a.]
$\boldsymbol{I_1}=\{6,8,4,13,9\}$\\
$\boldsymbol{L_1}\rightarrow \boldsymbol{A_0}:[6]\leftrightarrow \boldsymbol{A_2}:[4,8,9,13]$\\
$\boldsymbol{I_2}=\{21,12,7,14,5,16,10\}$\\
$\boldsymbol{L_2}\rightarrow \boldsymbol{A_0}:[21]\leftrightarrow \boldsymbol{A_1}:[7,12]\leftrightarrow \boldsymbol{A_2}:[5,10,14,16]$
\item[b.]
\begin{lstlisting}[language=Python]
def Search(x):
	for i = 0...len(L)-1:
		if A[i][0]<=x:
			BinarySearch x in A[i]:
				if x is found:
					return True
	return False
\end{lstlisting}
\item[c.]
\begin{lstlisting}[language=Python]
def Search(x):
	for i = 0...len(L) - 1:
		if A[i] is not in L:			# Binary representation of bit 0
			A[i] <- A				# Put A in i th position
		else:
			A <- Merge(A, A[i])
\end{lstlisting}
\item[d.]
\item[e.]
\begin{lstlisting}[language=Python]
def Delete(x):
	Let Aj be the samllest list in L.
	if x in the Aj:
		Aj.remove(x)
		if Aj is not size 0 #then it must be power of 2 - 1
			Then use a loop to split Aj to Aj-1...A0 and connect to L.
		else: remove Aj
	else if x is not in Aj:
		say x is in Aj+i
		switch x with the first element y in Aj;
		sort Aj+i   #we only need to move the y into proper place
		Aj.remove(x)
		if Aj is not size  #then it must be power of 2 - 1
			Then use a loop to split Aj to Aj-1...A0 and connect to L.
		else: remove Aj
end algorithm
\end{lstlisting}
the worst case if that we need to move x to the smallest list first, and then sort the list with $\mathcal{O}(n)$, then remove x with constant time, finally use $\mathcal{O}(n)$ to split the smallest set  Aj to Aj-1 to A0 and use $\mathcal{O}(log(n))$ to connect the linked list to L. The total cost of delete is $\mathcal{O}(n)$.
\end{itemize}

\newpage
\section*{Question 2}
\begin{itemize}
\item[a.]
For each house, use BFS to construct a BFS Tree. Then in each BFS Tree, the hospital node contains the length of the shortest path to the house. \\
Each BFS costs $\mathcal{O}(|V|+|E|)$. Since the number of house is constant, say $c\in\mathbb{N}$. Then the total runtime of all BFS's is $c\cdot\mathcal{O}(|V|+|E|)=\boldsymbol{\mathcal{O}(|V|+|E|})$
\item[b.]
Do BFS for each hospital. Given a house, in each BFS tree, the house node contains the the length of the shortest path to the root hospital. Since there are $k$ hospitals, there are $k$ shortest path from the house to a root hospital. Then find the minimum length of path among all shortest pathes.\\
Since each BFS costs $\mathcal{O}(|V|+|E|)$ of time, we do BFS for each hospital, then the runtime for constructing $k$ BFS trees is $\mathcal{O}(k(|V|+|E|))$. Min operation costs $\mathcal{O}(k)$ of time.\\
Thus, solving problem $P$ costs $\mathcal{O}(k(|V|+|E|)+k)$ = $\boldsymbol{\mathcal{O}(k(|V|+|E|))}$ of time.
\item[c.]
We will solve this problem with adjacency list of graph $G$. We loop through the head of adjacency list to find all the hospitals, assign distance to 0 and add all the hospitals to the Queue which cost $\mathcal{O}(|V|)$, then we use the same algorithm as BFS does. Use a while loop the pop the first hospital and find all the connected house, if the color of house is white, then assign the distance to distance of current node + 1 to each house they find and change the color to grey, finally, add those house that was originally white to the queue. if the color is grey, that means it already finds it closest hospital and we will not explore more. And the while loop will ends when all the node become black which means they all finds the closest hospital and this will cost the same as BFS does which is $\mathcal{O}(|V|+|E|)$, thus the total cost is $\mathcal{O}(2|V| + |E|)$ which is also $\mathcal{O}(|V| + |E|)$.

\end{itemize}

\end{document}







































