\documentclass[10pt]{article}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{fancybox}
\usepackage{amsfonts}
\usepackage{amsbsy}
\usepackage{tikz}
\usepackage{listings}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=10mm,
 bottom=15mm
 }
\usepackage{color}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\linespread{1.3}

\title{CSC263H1 Assignment 5}
\author{Jiatao Xiang, Xu Wang, Huakun Shen}
\date{March 14th, 2019}

\begin{document}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4
}
\lstset{style=mystyle}
\maketitle
\section*{Question 1}
\begin{itemize}
\item[a.]
$\boldsymbol{I_1}=\{6,8,4,13,9\}$\\
$\boldsymbol{L_1}\rightarrow \boldsymbol{A_0}:[6]\leftrightarrow \boldsymbol{A_2}:[4,8,9,13]$\\
$\boldsymbol{I_2}=\{21,12,7,14,5,16,10\}$\\
$\boldsymbol{L_2}\rightarrow \boldsymbol{A_0}:[21]\leftrightarrow \boldsymbol{A_1}:[7,12]\leftrightarrow \boldsymbol{A_2}:[5,10,14,16]$
\item[b.]
Traverse through $L$, for each array $A$, if the first element of $A>x$, then $x$ is not in $A$, because $A$ is in ascending order. If the first element of $A\leq x$, then $x$ may be in $A$. In this case, binary search $x$ in $A$. If $x$ is found, return $\boldsymbol{TRUE}$. If $x$ is not found, continue to next array.
\begin{lstlisting}[language=Python]
def Search(x):
	for i = 0...len(L)-1:
		if Ai[0]<=x:
			BinarySearch x in Ai:
				if x is found:
					return True
	return False
\end{lstlisting}
Suppose $L$ has $n$ elements, $len(L)$ is the length of the linked list, $len(L)$ is at most $(\lfloor\log_2n\rfloor + 1)$.
\begin{align*}
RT &= \Sigma^{\lfloor\log_2n\rfloor}_{i=0}i\\
&=\frac{\lfloor\log_2n\rfloor\cdot(\lfloor\log_2n\rfloor+1)}{2}\\
&=\mathcal{O}(\log(n)^2)
\end{align*}
The worst-case time complexity of $Search(x)$ is $\mathcal{O}(\log(n)^2)$.


\item[c.]Insert $x$ as an array of size 1, and merge this array with $L$. Call the array $A$.\\
Consider $L$ as a binary representation of $n$, where $n$ is the total number of element in $L$. 0 means there does not exist an array $A_i$ at index $i$, 1 means there exists an array $A_i$ at index $i$ with a size of $2^i$.\\
We want to insert the array $A$ in the position of the first occurence of 0 in binary representation. Before that, whenever a 1 is encountered (i.e. array $A$ and the array represented by the $``1"$ have the same size) merge the two arrays and carry on with the merged array until a 0 is encountered.
\begin{lstlisting}[language=Python]
def Insert(x):
	for i = 0...len(L) - 1:
		if Ai is not in L:			# Binary representation of bit 0
			Ai <- A					# Put A in i th position
		else:
			A <- Merge(A, Ai)
\end{lstlisting}
Suppose $L$ has $n$ elements, $len(L)$ is the length of the linked list, $len(L)$ is at most $(\lfloor\log_2n\rfloor + 1)$.
\begin{align*}
RT &= \Sigma^{\lfloor\log_2n\rfloor}_{i=0}2^{i+1}\\
&=2\cdot\Sigma^{\lfloor\log_2n\rfloor}_{i=0}2^i\\
&=2\cdot\frac{1-2^{\lfloor\log_2n\rfloor+1}}{1-2}\\
&=2^{\lfloor\log_2n\rfloor}\cdot2^2-2\\
&\leq 4n-2\\
&=\mathcal{O}(n)
\end{align*}
The worst-case time complexity of $Insert(x)$ is $\mathcal{O}(n)$.

\item[d.]The Amortized time per insert in a sequence of $n$ inserts is $\mathcal{O}(\log(n))$\\
\textbf{Aggregate Method:}\\
Let $T(n)$ denote the total runtime of a sequence of $n$ inserts.\\
For each merge of 2 $A_i$, i.e. merging 2 arrays of size $2^i$ costs at most $(2^{i+1}-1)$ comparisons.\\
In a sequence of $n$ inserts, the number of merges occuring between 2 $A_i$ arrays, i.e. 2 arrays of size $2^i$ is $\left\lfloor\frac{n}{2^{i+1}}\right\rfloor$.\\
For example, in a sequence of 16 inserts, the number of merges occuring between 2 $A_0$ arrays is $\left\lfloor\frac{16}{2^{0+1}}\right\rfloor = 8$, and 4 merges for $A_1$, 2 merges for $A_2$, 1 merge for $A_3$.
\begin{align*}
T(n) &= \left\lfloor\frac{n}{2^1}\right\rfloor\cdot(2^1-1)+\left\lfloor\frac{n}{2^2}\right\rfloor\cdot(2^2-1)+\left\lfloor\frac{n}{2^{i+1}}\right\rfloor\cdot(2^{i+1}-1)\\
&=\Sigma^{\lfloor\log_2n\rfloor}_{i=0}\left\lfloor\frac{n}{2^{i+1}}\right\rfloor\cdot(2^{i+1}-1)\\
&=\Sigma^{\lfloor\log_2n\rfloor}_{i=0}\left\lfloor\frac{n}{2^{i+1}}\right\rfloor\cdot2^{i+1}\\
&=\Sigma^{\lfloor\log_2n\rfloor}_{i=0}\frac{n}{2^{i+1}}\cdot2^{i+1}\\
&=\Sigma^{\lfloor\log_2n\rfloor}_{i=0}n\\
&=n\cdot\lfloor\log_2n\rfloor\\
&=\mathcal{O}(n\cdot\log(n))
\end{align*}
\begin{align*}
\text{Amortized runtime per insert}&=\frac{T(n)}{n}\hspace{20em}\\
&=\frac{n\cdot\log(n)}{n}\\
&=\mathcal{O}(\log(n))
\end{align*}
\textbf{Accounting Method}
\item[e.]
\end{itemize}

\newpage
\section*{Question 2}
\begin{itemize}
\item[a.]
For each house, use BFS to construct a BFS Tree. Then in each BFS Tree, the hospital node contains the length of the shortest path to the house. \\
Each BFS costs $\mathcal{O}(|V|+|E|)$. Since the number of house is constant, say $c\in\mathbb{N}$. Then the total runtime of all BFS's is $c\cdot\mathcal{O}(|V|+|E|)=\boldsymbol{\mathcal{O}(|V|+|E|})$
\item[b.]
Do BFS for each hospital. Given a house, in each BFS tree, the house node contains the the length of the shortest path to the root hospital. Since there are $k$ hospitals, there are $k$ shortest path from the house to a root hospital. Then find the minimum length of path among all shortest pathes.\\
Since each BFS costs $\mathcal{O}(|V|+|E|)$ of time, we do BFS for each hospital, then the runtime for constructing $k$ BFS trees is $\mathcal{O}(k(|V|+|E|))$. Min operation costs $\mathcal{O}(k)$ of time.\\
Thus, solving problem $P$ costs $\mathcal{O}(k(|V|+|E|)+k)$ = $\boldsymbol{\mathcal{O}(k(|V|+|E|))}$ of time.
\item[c.]
We will solve this problem with adjacency list of graph $G$.\\

\end{itemize}

\end{document}







































