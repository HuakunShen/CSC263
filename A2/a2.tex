\documentclass[10pt]{article}
\usepackage{amsmath}
\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }
\begin{document}
\noindent \textbf{CSC263 A2}\\
January 31, 2019\\
Xu Wang, Jiatao Xiang, Huakun Shen
\section*{Question 1}
\begin{enumerate}
\item[a.] Increase the key of a given item $x$ in a binomial max heap $H$ to
become $k$\\
\textbf{increase(H, x, k):}
\begin{enumerate}
\item[1)]Change the key value of $x$ to $k$, assume $k>x$
\item[2)]While the \underline{\textit{$x$ has a parent ($x$ is not a root)}} and \underline{\textit{the key of $x$'s parent is smaller than $k$}}:\\
Do step 3
\item[3)]switch the position of $x$ and its parent
\end{enumerate}
\textbf{Worst Case Runtime:}\\
Assume $H$ has $n$ nodes, $n=<b_t,b_{t-1},...,b_0>_2$,		where $t=\left\lfloor log_2n\right\rfloor$\\
$H=F_n:\text{ }<\text{all trees } B_i \text{ such that bit }b_i = 1>$\\
The largest binomial tree in $H$ is $B_t$, whose number of node is $2^t$, and height is $t$.\\
Then, in the worst case, $x$ needs to be switched at most $t$ times to become the root of its binomial tree.\\
Since $t=\left\lfloor log_2n\right\rfloor$, $x$ would be switched at most $\left\lfloor log_2n\right\rfloor$ times.\\
$RT_{WC}=\mathcal{O}(log_2n)$



\item[b.]Delete a given item $x$ from a binomial max heap $H$.\\
\textbf{remove(H, x):}
\begin{enumerate}
\item[1.]While $x$ is not the root of its binomial tree: \\do step 2
\item[2.]$increase(H, x, \text{key of }x's\text{ parent} + 1)$
\item[3.]Locate the maximum node $m$ of $H$, which is one of the roots of the binomial trees in the binomial heap\\
Let's say $B_i$ is the binomial tree that contains $m$, isolate $B_i$ and create a new binomial heap $U$\\
$U=H-B_i$
\item[4.]Delete the root node which was located in step 3, and make $S$ a new binomial tree of the result\\
$S=B_i-m$ \null\hfill ($m$ is the root of $B_i$, the max node in $H$)
\item[5.]$H\leftarrow Union(U,S)$
\end{enumerate}
\textbf{Worst Case Runtime:}
\begin{itemize}
\item
The goal of the step 1, 2 is to move and make $x$ the root of its binomial tree. Every time $x$'s key is increased to ($x$'s parent's key $+1$), $x$ switches with its parent. As explained in (a), a binomial heap with $n$ nodes has a maximum binomial tree of height $\lfloor log_2n\rfloor$, thus it takes at most $\lfloor log_2n\rfloor$ basic operations to make $x$ the root of its binomial tree. $RT_1=\mathcal{O}(log_2n)$
\item
Step 3 searches through the root of every binomial tree in the binomial heap to locate the maximum node in $H$\\
For a binomial heap with $n$ nodes, it has $\lfloor log_2n\rfloor$ binomial trees. Thus it takes at $\lfloor log_2n\rfloor$ steps to locate the binomial tree with the maximum node. $RT_2=\mathcal{O}(log_2n)$
\item
Step 4 deletes the root of a binomial tree, which takes constant time. $RT_3=\mathcal{O}(1)$
\item 
Step 5 makes $H$ the union of the results from step 3 and step 4, which takes $RT_3=\mathcal{O}(log_2n)$ of time
\item
$RT_{WC} = RT_1 + RT_2 + RT_3 + RT_4 = \mathcal{O}(log_2n)$
\end{itemize}
In brief, the algorithm of $remove(H, x)$ is:
\begin{enumerate}
\item $increase(H,x,\infty)$
\item $extract\_max(H)$ \null\hfill (The sum of step 3 - 5)
\end{enumerate}
\end{enumerate}
\newpage
\section*{Question 2}
\begin{enumerate}
\item
Our \textit{SuperHeap} is based on \textit{Binomial Max Heap}, with a little modification.\\
\textbf{Idea:} Always keep the minimum node of each binomial tree in the bottom, leftmost position. Then it takes less time to find the min node.\\
\textbf{How:} We store an extra information in each node,``a pointer to the leftmost(bottom) node in the binomial tree".\\
Let's say we perform all operations on a \textit{Binomial Min Heap} $T$, whose number of nodes$=n$.
\begin{enumerate}
\item \textit{Merge($D, D'$):}
Similar to the algorithm of \textit{Union} we talked about in class, except we perform one extra step, comparing and switching the leftmost node when merging two trees.\\
Merging two heaps is in fact performing ``merging two trees'' a bunch of times. \\
We first describe how to merge two trees. Call the two trees $t1$ and $t2$.
\begin{enumerate}
\item Compare the root of $t1$ and $t2$, the greater root becomes the root of the new tree, and let's suppose $t1$ has the greater root.
\item Then compare the leftmost node of both trees. If the leftmost node of the $t1$ is smaller, then switch the node with the leftmost node of the $t2$, to make sure the new tree's min node is in the leftmost position.
\item Note: When switching the two leftmost node, only switch the value, then we don't have to modify other node's pointers to the leftmost node.
\end{enumerate}
Comparing and switching the value of two nodes takes constant time. Overall, \textit{insert(k)} still takes $\mathcal{O}(log_2n)$ of time.
\item \textit{Insert(k):} 
\begin{enumerate}
\item Make a new binomial tree with a single node with key $k$, then union it with $T$. 

\end{enumerate}
The original \textit{insert(k)} takes $\mathcal{O}(log_2n)$ of time. 
\item \textit{ExtractMax():}\\
It's exactly symmetric to \textit{ExtractMin()} on \textit{Binomial Min Heap} 
\begin{enumerate}
\item Search through the root of every binomial tree in th ebinomial heap, call the node ``$max$'' and the tree it belongs to ``$t$''. There are at most $\lfloor log_2n \rfloor$ trees in the heap, so it takes $\mathcal{O}(log_2n)$ of time to find $max$.
\item Let $U=T-t$ \null\hfill ($U$ is the rest of the trees)
\item Let $S=t-max$ \null\hfill ($S$ is the remainders of $t$ after $max$ is removed from it)
\item Let $T=U \cup S$ \null\hfill (This takes $\mathcal{O}(\lfloor log_2n\rfloor)$ of time)
\end{enumerate}
\end{enumerate}
\item
\end{enumerate}
\end{document}






































